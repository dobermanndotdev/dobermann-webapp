/* tslint:disable */
/* eslint-disable */
/**
 * dobermann/backend
 * Dobermann\'s backend
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: firmino.changani@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CreateAccountRequest
 */
export interface CreateAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'account_name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface CreateMonitorRequest
 */
export interface CreateMonitorRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateMonitorRequest
     */
    'endpoint_url': string;
    /**
     * 
     * @type {number}
     * @memberof CreateMonitorRequest
     */
    'check_interval_in_seconds': number;
}
/**
 * 
 * @export
 * @interface EditMonitorRequest
 */
export interface EditMonitorRequest {
    /**
     * 
     * @type {string}
     * @memberof EditMonitorRequest
     */
    'endpoint_url': string;
    /**
     * 
     * @type {number}
     * @memberof EditMonitorRequest
     */
    'check_interval_in_seconds': number;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * A description about the error
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
    /**
     * Error custom error code such as \'email_in_use\'
     * @type {string}
     * @memberof ErrorResponse
     */
    'error': string;
}
/**
 * 
 * @export
 * @interface FullIncident
 */
export interface FullIncident {
    /**
     * 
     * @type {string}
     * @memberof FullIncident
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FullIncident
     */
    'checked_url': string;
    /**
     * 
     * @type {string}
     * @memberof FullIncident
     */
    'cause': string;
    /**
     * 
     * @type {string}
     * @memberof FullIncident
     */
    'resolved_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof FullIncident
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof FullIncident
     */
    'monitor_id': string;
    /**
     * 
     * @type {string}
     * @memberof FullIncident
     */
    'response_headers': string;
    /**
     * 
     * @type {string}
     * @memberof FullIncident
     */
    'request_headers': string;
    /**
     * 
     * @type {number}
     * @memberof FullIncident
     */
    'response_status': number;
    /**
     * 
     * @type {string}
     * @memberof FullIncident
     */
    'response_body': string;
}
/**
 * 
 * @export
 * @interface GenericResponse
 */
export interface GenericResponse {
    /**
     * 
     * @type {string}
     * @memberof GenericResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface GetAllMonitorByIdPayload
 */
export interface GetAllMonitorByIdPayload {
    /**
     * 
     * @type {Monitor}
     * @memberof GetAllMonitorByIdPayload
     */
    'data': Monitor;
}
/**
 * 
 * @export
 * @interface GetAllMonitorsPayload
 */
export interface GetAllMonitorsPayload {
    /**
     * 
     * @type {number}
     * @memberof GetAllMonitorsPayload
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof GetAllMonitorsPayload
     */
    'per_page': number;
    /**
     * 
     * @type {number}
     * @memberof GetAllMonitorsPayload
     */
    'page_count': number;
    /**
     * 
     * @type {number}
     * @memberof GetAllMonitorsPayload
     */
    'total_count': number;
    /**
     * 
     * @type {Array<Monitor>}
     * @memberof GetAllMonitorsPayload
     */
    'data': Array<Monitor>;
}
/**
 * 
 * @export
 * @interface GetIncidentByByIdPayload
 */
export interface GetIncidentByByIdPayload {
    /**
     * 
     * @type {FullIncident}
     * @memberof GetIncidentByByIdPayload
     */
    'data': FullIncident;
}
/**
 * 
 * @export
 * @interface GetMonitorResponseTimeStatsPayload
 */
export interface GetMonitorResponseTimeStatsPayload {
    /**
     * 
     * @type {Array<ResponseTimeStat>}
     * @memberof GetMonitorResponseTimeStatsPayload
     */
    'data': Array<ResponseTimeStat>;
}
/**
 * 
 * @export
 * @interface GetProfileDetailsPayload
 */
export interface GetProfileDetailsPayload {
    /**
     * 
     * @type {User}
     * @memberof GetProfileDetailsPayload
     */
    'data': User;
}
/**
 * 
 * @export
 * @interface Incident
 */
export interface Incident {
    /**
     * 
     * @type {string}
     * @memberof Incident
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Incident
     */
    'checked_url': string;
    /**
     * 
     * @type {string}
     * @memberof Incident
     */
    'cause': string;
    /**
     * 
     * @type {string}
     * @memberof Incident
     */
    'resolved_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Incident
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface LogInPayload
 */
export interface LogInPayload {
    /**
     * 
     * @type {string}
     * @memberof LogInPayload
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface LogInRequest
 */
export interface LogInRequest {
    /**
     * 
     * @type {string}
     * @memberof LogInRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LogInRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Monitor
 */
export interface Monitor {
    /**
     * 
     * @type {string}
     * @memberof Monitor
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Monitor
     */
    'endpoint_url': string;
    /**
     * 
     * @type {boolean}
     * @memberof Monitor
     */
    'is_endpoint_up': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Monitor
     */
    'is_paused': boolean;
    /**
     * 
     * @type {Array<Incident>}
     * @memberof Monitor
     */
    'incidents': Array<Incident>;
    /**
     * 
     * @type {string}
     * @memberof Monitor
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Monitor
     */
    'last_checked_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof Monitor
     */
    'check_interval_in_seconds': number;
}
/**
 * 
 * @export
 * @interface ResponseTimeStat
 */
export interface ResponseTimeStat {
    /**
     * 
     * @type {number}
     * @memberof ResponseTimeStat
     */
    'value': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseTimeStat
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseTimeStat
     */
    'region': string;
}
/**
 * 
 * @export
 * @interface ToggleMonitorPauseRequest
 */
export interface ToggleMonitorPauseRequest {
    /**
     * 
     * @type {boolean}
     * @memberof ToggleMonitorPauseRequest
     */
    'pause': boolean;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_name': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'role': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'created_at': string;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get details about the user currently logged in
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileDetails: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get details about the user currently logged in
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileDetails(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProfileDetailsPayload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfileDetails(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccountsApi.getProfileDetails']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get details about the user currently logged in
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileDetails(options?: any): AxiosPromise<GetProfileDetailsPayload> {
            return localVarFp.getProfileDetails(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * 
     * @summary Get details about the user currently logged in
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getProfileDetails(options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getProfileDetails(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new account
         * @param {CreateAccountRequest} createAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (createAccountRequest: CreateAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAccountRequest' is not null or undefined
            assertParamExists('createAccount', 'createAccountRequest', createAccountRequest)
            const localVarPath = `/auth/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Log in
         * @param {LogInRequest} logInRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (logInRequest: LogInRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logInRequest' is not null or undefined
            assertParamExists('login', 'logInRequest', logInRequest)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logInRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates a new account
         * @param {CreateAccountRequest} createAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(createAccountRequest: CreateAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(createAccountRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.createAccount']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Log in
         * @param {LogInRequest} logInRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(logInRequest: LogInRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogInPayload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(logInRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.login']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates a new account
         * @param {CreateAccountRequest} createAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(createAccountRequest: CreateAccountRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createAccount(createAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Log in
         * @param {LogInRequest} logInRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(logInRequest: LogInRequest, options?: any): AxiosPromise<LogInPayload> {
            return localVarFp.login(logInRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Creates a new account
     * @param {CreateAccountRequest} createAccountRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public createAccount(createAccountRequest: CreateAccountRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).createAccount(createAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Log in
     * @param {LogInRequest} logInRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(logInRequest: LogInRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).login(logInRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IncidentsApi - axios parameter creator
 * @export
 */
export const IncidentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get an incident by id
         * @param {string} incidentID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncidentByID: async (incidentID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'incidentID' is not null or undefined
            assertParamExists('getIncidentByID', 'incidentID', incidentID)
            const localVarPath = `/incidents/{incidentID}`
                .replace(`{${"incidentID"}}`, encodeURIComponent(String(incidentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IncidentsApi - functional programming interface
 * @export
 */
export const IncidentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IncidentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get an incident by id
         * @param {string} incidentID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIncidentByID(incidentID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIncidentByByIdPayload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIncidentByID(incidentID, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['IncidentsApi.getIncidentByID']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * IncidentsApi - factory interface
 * @export
 */
export const IncidentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IncidentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get an incident by id
         * @param {string} incidentID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncidentByID(incidentID: string, options?: any): AxiosPromise<GetIncidentByByIdPayload> {
            return localVarFp.getIncidentByID(incidentID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IncidentsApi - object-oriented interface
 * @export
 * @class IncidentsApi
 * @extends {BaseAPI}
 */
export class IncidentsApi extends BaseAPI {
    /**
     * 
     * @summary Get an incident by id
     * @param {string} incidentID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncidentsApi
     */
    public getIncidentByID(incidentID: string, options?: AxiosRequestConfig) {
        return IncidentsApiFp(this.configuration).getIncidentByID(incidentID, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MonitorsApi - axios parameter creator
 * @export
 */
export const MonitorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new monitor
         * @param {CreateMonitorRequest} createMonitorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMonitor: async (createMonitorRequest: CreateMonitorRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createMonitorRequest' is not null or undefined
            assertParamExists('createMonitor', 'createMonitorRequest', createMonitorRequest)
            const localVarPath = `/monitors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMonitorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete monitor
         * @param {string} monitorID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMonitor: async (monitorID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'monitorID' is not null or undefined
            assertParamExists('deleteMonitor', 'monitorID', monitorID)
            const localVarPath = `/monitors/{monitorID}`
                .replace(`{${"monitorID"}}`, encodeURIComponent(String(monitorID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a monitor by id
         * @param {string} monitorID 
         * @param {EditMonitorRequest} editMonitorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMonitor: async (monitorID: string, editMonitorRequest: EditMonitorRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'monitorID' is not null or undefined
            assertParamExists('editMonitor', 'monitorID', monitorID)
            // verify required parameter 'editMonitorRequest' is not null or undefined
            assertParamExists('editMonitor', 'editMonitorRequest', editMonitorRequest)
            const localVarPath = `/monitors/{monitorID}`
                .replace(`{${"monitorID"}}`, encodeURIComponent(String(monitorID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editMonitorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all monitors in a with pagination
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMonitors: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/monitors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all monitors in a with pagination
         * @param {string} monitorID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMonitorByID: async (monitorID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'monitorID' is not null or undefined
            assertParamExists('getMonitorByID', 'monitorID', monitorID)
            const localVarPath = `/monitors/{monitorID}`
                .replace(`{${"monitorID"}}`, encodeURIComponent(String(monitorID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the stats about the response time
         * @param {string} monitorID 
         * @param {number} [rangeInDays] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMonitorResponseTimeStats: async (monitorID: string, rangeInDays?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'monitorID' is not null or undefined
            assertParamExists('getMonitorResponseTimeStats', 'monitorID', monitorID)
            const localVarPath = `/monitors/{monitorID}/stats/response-times`
                .replace(`{${"monitorID"}}`, encodeURIComponent(String(monitorID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (rangeInDays !== undefined) {
                localVarQueryParameter['range_in_days'] = rangeInDays;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pause or unpause the monitor
         * @param {string} monitorID 
         * @param {ToggleMonitorPauseRequest} toggleMonitorPauseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleMonitorPause: async (monitorID: string, toggleMonitorPauseRequest: ToggleMonitorPauseRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'monitorID' is not null or undefined
            assertParamExists('toggleMonitorPause', 'monitorID', monitorID)
            // verify required parameter 'toggleMonitorPauseRequest' is not null or undefined
            assertParamExists('toggleMonitorPause', 'toggleMonitorPauseRequest', toggleMonitorPauseRequest)
            const localVarPath = `/monitors/{monitorID}`
                .replace(`{${"monitorID"}}`, encodeURIComponent(String(monitorID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(toggleMonitorPauseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MonitorsApi - functional programming interface
 * @export
 */
export const MonitorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MonitorsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new monitor
         * @param {CreateMonitorRequest} createMonitorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMonitor(createMonitorRequest: CreateMonitorRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMonitor(createMonitorRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MonitorsApi.createMonitor']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete monitor
         * @param {string} monitorID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMonitor(monitorID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMonitor(monitorID, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MonitorsApi.deleteMonitor']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Edit a monitor by id
         * @param {string} monitorID 
         * @param {EditMonitorRequest} editMonitorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editMonitor(monitorID: string, editMonitorRequest: EditMonitorRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editMonitor(monitorID, editMonitorRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MonitorsApi.editMonitor']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get all monitors in a with pagination
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMonitors(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllMonitorsPayload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMonitors(page, limit, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MonitorsApi.getAllMonitors']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get all monitors in a with pagination
         * @param {string} monitorID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMonitorByID(monitorID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllMonitorByIdPayload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMonitorByID(monitorID, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MonitorsApi.getMonitorByID']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get the stats about the response time
         * @param {string} monitorID 
         * @param {number} [rangeInDays] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMonitorResponseTimeStats(monitorID: string, rangeInDays?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMonitorResponseTimeStatsPayload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMonitorResponseTimeStats(monitorID, rangeInDays, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MonitorsApi.getMonitorResponseTimeStats']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Pause or unpause the monitor
         * @param {string} monitorID 
         * @param {ToggleMonitorPauseRequest} toggleMonitorPauseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toggleMonitorPause(monitorID: string, toggleMonitorPauseRequest: ToggleMonitorPauseRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toggleMonitorPause(monitorID, toggleMonitorPauseRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MonitorsApi.toggleMonitorPause']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * MonitorsApi - factory interface
 * @export
 */
export const MonitorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MonitorsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new monitor
         * @param {CreateMonitorRequest} createMonitorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMonitor(createMonitorRequest: CreateMonitorRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createMonitor(createMonitorRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete monitor
         * @param {string} monitorID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMonitor(monitorID: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMonitor(monitorID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a monitor by id
         * @param {string} monitorID 
         * @param {EditMonitorRequest} editMonitorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMonitor(monitorID: string, editMonitorRequest: EditMonitorRequest, options?: any): AxiosPromise<void> {
            return localVarFp.editMonitor(monitorID, editMonitorRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all monitors in a with pagination
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMonitors(page?: number, limit?: number, options?: any): AxiosPromise<GetAllMonitorsPayload> {
            return localVarFp.getAllMonitors(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all monitors in a with pagination
         * @param {string} monitorID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMonitorByID(monitorID: string, options?: any): AxiosPromise<GetAllMonitorByIdPayload> {
            return localVarFp.getMonitorByID(monitorID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the stats about the response time
         * @param {string} monitorID 
         * @param {number} [rangeInDays] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMonitorResponseTimeStats(monitorID: string, rangeInDays?: number, options?: any): AxiosPromise<GetMonitorResponseTimeStatsPayload> {
            return localVarFp.getMonitorResponseTimeStats(monitorID, rangeInDays, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Pause or unpause the monitor
         * @param {string} monitorID 
         * @param {ToggleMonitorPauseRequest} toggleMonitorPauseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleMonitorPause(monitorID: string, toggleMonitorPauseRequest: ToggleMonitorPauseRequest, options?: any): AxiosPromise<void> {
            return localVarFp.toggleMonitorPause(monitorID, toggleMonitorPauseRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MonitorsApi - object-oriented interface
 * @export
 * @class MonitorsApi
 * @extends {BaseAPI}
 */
export class MonitorsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new monitor
     * @param {CreateMonitorRequest} createMonitorRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorsApi
     */
    public createMonitor(createMonitorRequest: CreateMonitorRequest, options?: AxiosRequestConfig) {
        return MonitorsApiFp(this.configuration).createMonitor(createMonitorRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete monitor
     * @param {string} monitorID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorsApi
     */
    public deleteMonitor(monitorID: string, options?: AxiosRequestConfig) {
        return MonitorsApiFp(this.configuration).deleteMonitor(monitorID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a monitor by id
     * @param {string} monitorID 
     * @param {EditMonitorRequest} editMonitorRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorsApi
     */
    public editMonitor(monitorID: string, editMonitorRequest: EditMonitorRequest, options?: AxiosRequestConfig) {
        return MonitorsApiFp(this.configuration).editMonitor(monitorID, editMonitorRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all monitors in a with pagination
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorsApi
     */
    public getAllMonitors(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return MonitorsApiFp(this.configuration).getAllMonitors(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all monitors in a with pagination
     * @param {string} monitorID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorsApi
     */
    public getMonitorByID(monitorID: string, options?: AxiosRequestConfig) {
        return MonitorsApiFp(this.configuration).getMonitorByID(monitorID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the stats about the response time
     * @param {string} monitorID 
     * @param {number} [rangeInDays] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorsApi
     */
    public getMonitorResponseTimeStats(monitorID: string, rangeInDays?: number, options?: AxiosRequestConfig) {
        return MonitorsApiFp(this.configuration).getMonitorResponseTimeStats(monitorID, rangeInDays, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Pause or unpause the monitor
     * @param {string} monitorID 
     * @param {ToggleMonitorPauseRequest} toggleMonitorPauseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorsApi
     */
    public toggleMonitorPause(monitorID: string, toggleMonitorPauseRequest: ToggleMonitorPauseRequest, options?: AxiosRequestConfig) {
        return MonitorsApiFp(this.configuration).toggleMonitorPause(monitorID, toggleMonitorPauseRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



